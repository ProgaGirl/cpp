Урок 4: Пространства имен и управление зависимостями

## 1. Создание и использование пространств имен

### 1.1. Что такое пространство имен?
Пространство имен (namespace) в C++ используется для организации кода и предотвращения конфликтов имен. Оно позволяет сгруппировать функции, классы, переменные и другие идентификаторы, чтобы избежать их коллизий, когда одинаковые имена используются в разных частях программы.

### 1.2. Синтаксис объявления пространства имен
Для создания пространства имен используется ключевое слово `namespace`, за которым следует имя пространства и блок кода в фигурных скобках. Например:

```cpp
namespace MyNamespace {
    int variable = 10;
    void myFunction() {
        // тело функции
    }
}
```

В этом примере `variable` и `myFunction` принадлежат пространству имен `MyNamespace`.

### 1.3. Доступ к элементам пространства имен
Для доступа к элементам пространства имен используется оператор `::` (оператор разрешения области видимости). Например:

```cpp
int value = MyNamespace::variable;
MyNamespace::myFunction();
```

### 1.4. Директива `using`
Чтобы упростить доступ к элементам пространства имен, можно использовать директиву `using`:

```cpp
using namespace MyNamespace;
variable = 20;
myFunction();
```

Это приводит к тому, что все элементы пространства имен `MyNamespace` становятся доступными без явного указания.

### 1.5. Вложенные пространства имен
Пространства имен могут быть вложенными:

```cpp
namespace OuterNamespace {
    namespace InnerNamespace {
        void innerFunction() {
            // тело функции
        }
    }
}
```

Для доступа к `innerFunction` необходимо использовать полное имя:

```cpp
OuterNamespace::InnerNamespace::innerFunction();
```

### 1.6. Анонимные пространства имен
Анонимные пространства имен используются для ограничения видимости элементов в пределах одного файла:

```cpp
namespace {
    int hiddenVariable = 100;
}
```

Элементы внутри анонимного пространства имен доступны только в пределах текущего файла, что позволяет избежать их конфликта с элементами из других файлов.

## 2. Понимание и использование заголовочных файлов

### 2.1. Что такое заголовочные файлы?
Заголовочные файлы (.h или .hpp) в C++ содержат объявления классов, функций и переменных, которые можно использовать в разных исходных файлах. Они помогают разделять интерфейс и реализацию.

### 2.2. Преимущества использования заголовочных файлов
- **Разделение интерфейса и реализации**: Заголовочные файлы содержат только объявления, а реализация находится в отдельных файлах (.cpp).
- **Управление зависимостями**: Позволяют избегать избыточного повторного написания кода.
- **Упрощение поддержки и модульности**: Код становится более читаемым и удобным для сопровождения.

### 2.3. Структура заголовочного файла
Обычно заголовочный файл включает:
- Защитные макросы (или `#pragma once`).
- Объявления классов, функций и переменных.
- Необходимые директивы `#include`.

Пример заголовочного файла `MyClass.h`:

```cpp
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass {
public:
    void printMessage();
};

#endif // MYCLASS_H
```

## 3. Применение `#include`, `#define`, `#pragma once`

### 3.1. Директива `#include`
Директива `#include` используется для включения содержимого одного файла в другой. Различают два типа включений:
- **Системные заголовочные файлы**: Включаются с использованием угловых скобок `< >`, например: `#include <iostream>`.
- **Пользовательские заголовочные файлы**: Включаются с использованием кавычек `" "`, например: `#include "MyClass.h"`.

Системные файлы ищутся в стандартных директориях компилятора, а пользовательские — в директориях проекта.

### 3.2. Директива `#define`
Директива `#define` используется для определения макросов — именованных констант или текстовых замен:

```cpp
#define PI 3.14159
#define SQUARE(x) ((x) * (x))
```

Макросы заменяются компилятором на соответствующий текст на этапе предварительной обработки. Это может помочь уменьшить дублирование кода, но стоит использовать их с осторожностью, так как они могут затруднить отладку.

### 3.3. Директива `#pragma once`
`#pragma once` — это альтернатива защитным макросам в заголовочных файлах. Она предотвращает множественное включение одного и того же заголовочного файла:

```cpp
#pragma once

class MyClass {
    // Объявления
};
```

Она проще и удобнее защитных макросов, так как не требует создания уникальных имен для макросов.

### 4. Организация кода и управление зависимостями в больших проектах

При работе над большими проектами с множеством файлов и компонентов важно организовывать код таким образом, чтобы минимизировать зависимости и улучшить читаемость и поддержку проекта. В этом разделе мы рассмотрим некоторые рекомендации и паттерны для управления зависимостями и организацией кода.

#### 4.1. Разделение на модули

Одним из ключевых принципов при разработке больших проектов является разделение кода на модули. Модуль может представлять собой логически связанный набор классов и функций, отвечающих за конкретный функционал.

- **Модульность** позволяет изменять и тестировать отдельные компоненты без необходимости вносить изменения в весь проект.
- **Инкапсуляция**: Модули скрывают реализацию и предоставляют интерфейсы, что упрощает использование и тестирование.

Для каждого модуля следует создать:
- **Заголовочный файл** (.h), который содержит объявления классов, функций и переменных.
- **Файл реализации** (.cpp), где описана логика работы модуля.

Пример структуры проекта:

```
Project/
│
├── main.cpp
├── ModuleA/
│   ├── ModuleA.h
│   └── ModuleA.cpp
└── ModuleB/
    ├── ModuleB.h
    └── ModuleB.cpp
```

#### 4.2. Управление зависимостями

Когда модули используют функциональность друг друга, важно контролировать зависимости между ними, чтобы избежать циклических зависимостей и излишних включений заголовочных файлов.

- **Использование `#include` только в необходимости**: Включайте заголовочные файлы только в тех случаях, когда они действительно необходимы.
- **Использование предварительных объявлений** (forward declarations): Если в заголовочном файле нужно сослаться на тип, объявленный в другом модуле, можно использовать предварительное объявление.

```cpp
// ModuleA.h
#ifndef MODULEA_H
#define MODULEA_H

class ModuleB;  // Предварительное объявление класса

class ModuleA {
public:
    void setModuleB(ModuleB* b);
private:
    ModuleB* moduleB;
};

#endif // MODULEA_H
```

- **Избегание циклических зависимостей**: Структурируйте код так, чтобы модули не зависели друг от друга напрямую. Если это невозможно, рассмотрите возможность использования интерфейсов или абстрактных классов.

#### 4.3. Пример использования интерфейсов для управления зависимостями

Интерфейсы (абстрактные классы) позволяют разделить интерфейс и реализацию, что упрощает замену реализаций и тестирование. Например:

```cpp
// IModuleB.h
#ifndef IMODULEB_H
#define IMODULEB_H

class IModuleB {
public:
    virtual void doSomething() = 0;
    virtual ~IModuleB() = default;
};

#endif // IMODULEB_H
```

Теперь `ModuleA` может работать с интерфейсом `IModuleB`, не зная о конкретной реализации `ModuleB`.

```cpp
// ModuleA.h
#ifndef MODULEA_H
#define MODULEA_H

#include "IModuleB.h"

class ModuleA {
public:
    void setModuleB(IModuleB* b);
    void useModuleB();
private:
    IModuleB* moduleB;
};

#endif // MODULEA_H
```

```cpp
// ModuleA.cpp
#include "ModuleA.h"

void ModuleA::setModuleB(IModuleB* b) {
    moduleB = b;
}

void ModuleA::useModuleB() {
    if (moduleB) {
        moduleB->doSomething();
    }
}
```

Такое использование интерфейсов помогает управлять зависимостями между модулями и упрощает замену и тестирование компонентов.

#### 4.4. Использование пространств имен для больших проектов

Для больших проектов рекомендуется создавать иерархию пространств имен, чтобы избежать конфликтов имен и организовать код. Например, если в проекте много модулей, можно использовать такую структуру пространств имен:

```cpp
namespace Project {
    namespace ModuleA {
        class ClassA {
            // ...
        };
    }

    namespace ModuleB {
        class ClassB {
            // ...
        };
    }
}
```

Теперь доступ к классам осуществляется через полный путь:

```cpp
Project::ModuleA::ClassA objectA;
Project::ModuleB::ClassB objectB;
```

### 5. Инструменты сборки и управление зависимостями

Для больших проектов важно использовать инструменты сборки, такие как CMake, Makefile или системы управления проектами в IDE, чтобы автоматически собирать проект и управлять зависимостями.

#### 5.1. Использование CMake

CMake — мощный инструмент для управления сборкой проектов. Он позволяет автоматически генерировать Makefile или проекты для разных IDE.

Да, CMake может генерировать файлы `Makefile`, но не только их. CMake — это кроссплатформенный инструмент для автоматической генерации файлов сборки, таких как `Makefile` для `make`, проекты для Visual Studio, Xcode и многие другие. Суть CMake в том, чтобы предоставить единый способ описания процесса сборки, который затем может быть преобразован в формат, соответствующий нужному инструменту сборки на конкретной платформе.

##### Как работает CMake?

1. **Создание CMakeLists.txt**: Сначала создаётся файл `CMakeLists.txt`, в котором указываются исходные файлы, заголовочные файлы, необходимые библиотеки и параметры компиляции.

2. **Генерация файлов сборки**: На основе `CMakeLists.txt` CMake генерирует файлы сборки, которые используются инструментами на конкретной платформе. Это могут быть:
   - `Makefile` для UNIX-подобных систем (Linux, macOS и т. д.).
   - Проекты для Visual Studio (`.sln` и `.vcxproj`).
   - Проекты для Xcode.
   - Файлы для Ninja (`build.ninja`).
   - И многие другие.

3. **Сборка проекта**: После генерации файлов сборки используется соответствующий инструмент для компиляции и линковки программы. Например, в случае `Makefile` это будет команда `make`.

##### Пример использования CMake для генерации Makefile

Предположим, у нас есть простая структура проекта (смотри папку **cmake_example**):

```
project/
├── CMakeLists.txt
└── main.cpp
```

Содержимое `main.cpp`:

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, CMake!" << std::endl;
    return 0;
}
```

Содержимое `CMakeLists.txt`:

```cmake
cmake_minimum_required(VERSION 3.10)
project(HelloCMake)

# Указываем стандарт C++
set(CMAKE_CXX_STANDARD 17)

# Добавляем исполняемый файл
add_executable(HelloCMake main.cpp)
```

Теперь, чтобы создать `Makefile` на UNIX-подобной системе, выполняем следующие команды в терминале:

```bash
# Создаем директорию для сборки
mkdir build
cd build

# Генерируем Makefile
cmake ..

# Запускаем сборку
make
```

##### Результат

- Команда `cmake ..` прочитает `CMakeLists.txt` и сгенерирует `Makefile` в папке `build`.
- Команда `make` использует `Makefile` для компиляции и линковки проекта.

Таким образом, CMake не выполняет сборку напрямую, а лишь генерирует файлы, которые будут использоваться инструментами сборки, такими как `make`, для компиляции проекта.

##### Пример с несколькими модулями

Пример CMakeLists.txt для проекта с несколькими модулями:

```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject)

# Установка стандартов C++
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# Добавление поддиректорий с модулями
add_subdirectory(ModuleA)
add_subdirectory(ModuleB)

# Главный исполняемый файл
add_executable(MyProject main.cpp)

# Линковка модулей
target_link_libraries(MyProject ModuleA ModuleB)
```

#### 5.2. Работа с внешними зависимостями

Для подключения сторонних библиотек можно использовать пакетные менеджеры, такие как vcpkg, Conan или встроенные механизмы в CMake.

Пример добавления внешней библиотеки в CMake:

```cmake
find_package(MyExternalLib REQUIRED)
target_link_libraries(MyProject MyExternalLib::MyExternalLib)
```

## Заключение

В этом уроке рассмотрены основные аспекты использования пространств имен и управления зависимостями с помощью заголовочных файлов, директив `#include`, `#define` и `#pragma once`. Эти инструменты помогают создавать структурированный и модульный код, избегать конфликтов имен и эффективно управлять зависимостями в проектах на C++.

Кроме того, для больших проектов важно использовать системы автоматизации сборки, такие как CMake, которые упрощают управление зависимостями, позволяют генерировать файлы сборки для различных платформ и инструментов, таких как Make или Visual Studio, и обеспечивают гибкую настройку процесса компиляции и линковки. Применение CMake помогает централизованно управлять конфигурацией сборки, минимизировать ручную работу и повышает переносимость проектов между различными средами разработки.

# Домашнее задание

### 1) Решаем задачи L04-*

### 2) Создание многомодульного проекта с использованием CMake

#### Описание

Необходимо создать проект на C++, состоящий из нескольких модулей, и настроить его сборку с помощью CMake. Проект должен включать следующие компоненты:

1. **Библиотека `MathFunctions`**:
   - Содержит функции для вычисления математических операций, таких как возведение в квадрат (`square`) и куб (`cube`).
   - Заголовочный файл: `MathFunctions.h`.
   - Файл реализации: `MathFunctions.cpp`.

2. **Библиотека `StringUtilities`**:
   - Содержит функции для работы со строками, такие как подсчёт количества символов (`countChars`) и проверка, является ли строка палиндромом (`isPalindrome`).
   - Заголовочный файл: `StringUtilities.h`.
   - Файл реализации: `StringUtilities.cpp`.

3. **Исполняемый файл `MainApp`**:
   - Использует библиотеки `MathFunctions` и `StringUtilities`.
   - В главной функции (`main`) тестируются функции обеих библиотек.

#### Требования

1. Создать структуру проекта следующего вида:

    ```
    MultiModuleProject/
    ├── CMakeLists.txt
    ├── MathFunctions/
    │   ├── CMakeLists.txt
    │   ├── MathFunctions.h
    │   └── MathFunctions.cpp
    ├── StringUtilities/
    │   ├── CMakeLists.txt
    │   ├── StringUtilities.h
    │   └── StringUtilities.cpp
    └── MainApp/
        ├── CMakeLists.txt
        └── main.cpp
    ```

2. В корневом `CMakeLists.txt`:
   - Подключить все модули проекта (`MathFunctions`, `StringUtilities`, `MainApp`).
   - Указать стандарт C++17.

3. В `CMakeLists.txt` каждого модуля:
   - Создать библиотеку или исполняемый файл.
   - Указать необходимые зависимости между модулями.

4. В `main.cpp` протестировать работу всех функций:
   - Вызвать функции из библиотеки `MathFunctions` для вычисления квадрата и куба числа.
   - Использовать функции из `StringUtilities` для работы со строками.

5. Добавить тесты в `main.cpp` для проверки корректной работы каждой функции.

#### Дополнительные задания

1. **Реализовать сборку проекта в отдельной директории `build`**:
   - Создать в корне проекта папку `build` и собрать проект с помощью команд:
     ```bash
     mkdir build
     cd build
     cmake ..
     make
     ```
   
2. **Добавить возможность установки проекта (`make install`)**:
   - Настроить установку бинарных файлов и библиотек в целевые директории.

3. **Настроить опцию включения/выключения каждой библиотеки через CMake**:
   - Добавить опции в корневой `CMakeLists.txt` для управления сборкой каждой библиотеки:
     ```cmake
     option(BUILD_MATH_FUNCTIONS "Build MathFunctions library" ON)
     option(BUILD_STRING_UTILITIES "Build StringUtilities library" ON)
     ```
   - Реализовать проверку этих опций и подключать библиотеки только при их активации.

#### Итоговое задание

1. **Создайте новую папку с вашим именем** в уроке 4 папке `assignments/` (например, `assignments/lesson04/ivanov/`).
2. Поместите туда ваш проект с правильной структурой и всеми необходимыми файлами.
3. Сделайте `commit` и `push` вашего решения в ваш репозиторий.
4. Создайте **pull request** с вашим решением в основной репозиторий курса. В описании PR укажите ваше имя и краткое описание выполненного задания.

#### Ожидаемый результат

- Корректно работающий проект с разделением на модули, собранный с помощью CMake.
- Возможность сборки и тестирования всех функций из `MathFunctions` и `StringUtilities` в программе `MainApp`.
- Созданный `pull request` с вашим решением в основной репозиторий курса.