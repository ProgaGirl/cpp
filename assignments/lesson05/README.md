# Урок 5: Стандартные библиотеки C++17
**Тема:** `std::optional`, `std::variant`, `std::any`  


#### **1. Введение в новые типы данных C++17**

С выходом C++17 в стандартную библиотеку были добавлены три новых типа данных: `std::optional`, `std::variant` и `std::any`. Они помогают разработчикам управлять неопределёнными или разнородными данными более безопасно и выразительно. Рассмотрим каждый тип по отдельности.


#### **2. std::optional**
`std::optional` — это шаблонный тип, который может либо хранить значение, либо не хранить его вовсе (null-like состояние). Это удобно в тех случаях, когда функция или переменная может вернуть либо конкретное значение, либо отсутствие значения.

##### **Пример синтаксиса и применения:**

```cpp
#include <optional>
#include <iostream>

std::optional<int> find(int value) {
    if (value > 0)
        return value;  // Возвращаем значение
    return std::nullopt;  // Отсутствие значения
}

int main() {
    std::optional<int> result = find(10);
    
    if (result)  // Проверка на наличие значения
        std::cout << "Value: " << *result << std::endl;
    else
        std::cout << "No value found" << std::endl;
}
```

##### **Когда использовать:**
- Когда функция может не вернуть результат (например, поиск в базе данных, где результат может отсутствовать).
- В ситуациях, когда наличие или отсутствие значения должно быть явно указано (вместо использования `nullptr` или магических чисел вроде `-1`).

##### **Плюсы:**
- Избегание неопределённого поведения при работе с отсутствующими значениями.
- Явный контроль над отсутствием результата.

---

#### **3. std::variant**
`std::variant` — это тип-объединение (union-like тип), который может содержать одно значение из нескольких типов. Это похоже на `union`, но безопаснее, так как `std::variant` хранит информацию о том, какой тип данных он содержит в текущий момент.

##### **Пример синтаксиса и применения:**

```cpp
#include <variant>
#include <iostream>

using VarType = std::variant<int, double, std::string>;

void printVariant(const VarType& v) {
    std::visit([](auto&& arg) { std::cout << arg << std::endl; }, v);
}

int main() {
    VarType v1 = 10;
    VarType v2 = 3.14;
    VarType v3 = "Hello";

    printVariant(v1);
    printVariant(v2);
    printVariant(v3);
}
```

##### **Когда использовать:**
- Когда требуется хранить значение, которое может быть одного из нескольких типов.
- В случаях, когда используется замена старым `union`, но с более безопасной обработкой типов.
- Для создания API, где функции могут возвращать разные типы данных в зависимости от условий.

##### **Плюсы:**
- Типобезопасность: в отличие от `union`, `std::variant` сохраняет тип данных и проверяет его во время выполнения.
- Возможность обрабатывать различные типы с помощью `std::visit`, что упрощает код.

---

#### **4. std::any**
`std::any` — это тип, который может хранить значения любого типа. Это аналог контейнера для "любой" переменной, который может использоваться для динамического хранения данных. При этом тип данных известен только во время выполнения.

##### **Пример синтаксиса и применения:**

```cpp
#include <any>
#include <iostream>
#include <string>

void printAny(const std::any& a) {
    if (a.type() == typeid(int)) {
        std::cout << "int: " << std::any_cast<int>(a) << std::endl;
    } else if (a.type() == typeid(double)) {
        std::cout << "double: " << std::any_cast<double>(a) << std::endl;
    } else if (a.type() == typeid(std::string)) {
        std::cout << "string: " << std::any_cast<std::string>(a) << std::endl;
    }
}

int main() {
    std::any a = 10;
    printAny(a);

    a = 3.14;
    printAny(a);

    a = std::string("Hello");
    printAny(a);
}
```

##### **Когда использовать:**
- Когда необходимо хранить данные любого типа, и тип данных известен только во время выполнения.
- В ситуациях, когда система должна быть гибкой и поддерживать разные типы данных (например, в конфигурационных системах, сериализации данных, универсальных контейнерах).

##### **Плюсы:**
- Позволяет хранить объекты любого типа.
- Обеспечивает безопасное преобразование типов через `std::any_cast` с проверкой типов.

##### **Минусы:**
- Невозможно использовать без динамического приведения типов (`std::any_cast`).
- Более сложный в использовании по сравнению с `std::variant`, если количество возможных типов невелико.

---

# JSON библотека

Библиотека [nlohmann/json](https://github.com/nlohmann/json) — это популярная библиотека для работы с JSON в C++. Она предоставляет простой и интуитивный интерфейс для создания, парсинга и сериализации данных JSON. Давай рассмотрим основные возможности библиотеки и научимся работать с ней.

### 1. **Установка библиотеки**

Чтобы начать использовать `nlohmann/json`, можно скачать заголовочный файл `json.hpp` с официального [GitHub-репозитория](https://github.com/nlohmann/json). Библиотека не требует сборки — она состоит из одного заголовочного файла, который нужно просто подключить в проект.

Если ты используешь пакетный менеджер, можно установить библиотеку через `vcpkg`:

```bash
vcpkg install nlohmann-json
```

Или через `Conan`:

```bash
conan install nlohmann_json/3.9.1@
```

### 2. **Подключение библиотеки**

Подключить библиотеку можно следующим образом:

```cpp
#include <nlohmann/json.hpp>  // Заголовочный файл библиотеки
```

Для упрощения работы с JSON можно использовать псевдоним:

```cpp
using json = nlohmann::json;
```

### 3. **Создание JSON-объектов**

`nlohmann/json` позволяет легко создавать JSON-объекты с помощью синтаксиса, схожего с инициализацией стандартных контейнеров.

#### Пример создания JSON-объекта:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    // Создание JSON-объекта
    json j = {
        {"name", "Alice"},
        {"age", 25},
        {"is_active", true},
        {"skills", {"C++", "Python", "Java"}}
    };

    std::cout << j.dump(4) << std::endl;  // Вывод JSON с отступами
    return 0;
}
```

**Результат:**
```json
{
    "age": 25,
    "is_active": true,
    "name": "Alice",
    "skills": [
        "C++",
        "Python",
        "Java"
    ]
}
```

#### **Методы для работы с JSON-объектами:**

- **`j["key"]`**: Доступ к значению по ключу.
- **`j.at("key")`**: Альтернативный безопасный способ доступа (выбрасывает исключение при отсутствии ключа).
- **`j.size()`**: Возвращает размер JSON-объекта или массива.
- **`j.contains("key")`**: Проверяет наличие ключа в объекте.
- **`j.dump()`**: Преобразует объект JSON в строку. Можно указать отступы для более читабельного вывода, например `j.dump(4)`.

### 4. **Парсинг JSON-строки**

Библиотека поддерживает удобный синтаксис для парсинга JSON из строк.

#### Пример:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    // JSON-строка
    std::string json_string = R"(
        {
            "name": "Bob",
            "age": 30,
            "is_active": false,
            "skills": ["JavaScript", "HTML", "CSS"]
        }
    )";

    // Парсинг строки в JSON-объект
    json j = json::parse(json_string);

    std::cout << "Name: " << j["name"] << std::endl;
    std::cout << "Age: " << j["age"] << std::endl;
    std::cout << "Is Active: " << j["is_active"] << std::endl;

    return 0;
}
```

**Результат:**
```
Name: Bob
Age: 30
Is Active: false
```

####  **Обратите внимание** Сырая строка

`R` в начале строки — это обозначение **сырой строки** (raw string literal) в C++. Такой синтаксис позволяет включать специальные символы (например, обратные слэши `\`, кавычки `"`, символы новой строки) без необходимости экранировать их.

В обычной строке C++ нужно экранировать специальные символы с помощью обратного слэша:
```cpp
std::string normal_string = "This is a \"quoted\" string with a newline character \\n.";
```

Сырая строка (raw string) позволяет писать строку напрямую без экранирования:
```cpp
std::string raw_string = R"(This is a "quoted" string with a newline character \n.)";
```

Особенности сырой строки:
1. Строка начинается с `R"(` и заканчивается `)"`.
2. Все символы внутри этих скобок трактуются буквально, без экранирования.
3. Сырой строкой удобно задавать многострочные литералы, такие как JSON, регулярные выражения или файлы с кодом.

В твоем примере:
```cpp
std::string json_string = R"(
        {
            "name": "Bob",
            "age": 30,
            "is_active": false,
            "skills": ["JavaScript", "HTML", "CSS"]
        }
    )";
```
Используется сырая строка для JSON, чтобы избежать экранирования кавычек и символов новой строки. Это делает код более читабельным и проще в написании, особенно при работе с многострочными текстами.

### 5. **Доступ и изменение значений**

Доступ к значениям осуществляется с помощью операторов квадратных скобок, а также можно изменять значения в объекте.

#### Пример:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    json j = {
        {"name", "Alice"},
        {"age", 25},
        {"is_active", true}
    };

    // Доступ к значениям
    std::string name = j["name"];
    int age = j["age"];
    bool is_active = j["is_active"];

    // Изменение значений
    j["age"] = 26;
    j["is_active"] = false;

    std::cout << j.dump(4) << std::endl;
    return 0;
}
```

**Результат:**
```json
{
    "age": 26,
    "is_active": false,
    "name": "Alice"
}
```

### 6. **Работа с массивами**

JSON-массивы в библиотеке представлены как обычные списки или векторы. Вы можете создавать массивы и обращаться к их элементам по индексу.

#### Пример работы с массивами:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    // JSON-массив
    json j = {
        {"languages", {"C++", "Python", "PHP"}},
        {"scores", {85, 90, 78}}
    };

    // Доступ к элементам массива
    for (const auto& language : j["languages"]) {
        std::cout << "Language: " << language << std::endl;
    }

    // Изменение элементов массива
    j["scores"][0] = 95;  // Меняем оценку

    std::cout << j.dump(4) << std::endl;

    return 0;
}
```

**Результат:**
```json
{
    "languages": [
        "C++",
        "Python",
        "PHP"
    ],
    "scores": [
        95,
        90,
        78
    ]
}
```

### 7. **Сериализация (преобразование в строку)**

Для преобразования JSON-объекта обратно в строку используйте метод `dump()`. Можно указать параметр для отступов, чтобы получить форматированный JSON.

#### Пример:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    json j = {
        {"name", "Charlie"},
        {"age", 29},
        {"is_active", true}
    };

    // Преобразование JSON в строку
    std::string serialized = j.dump();      // Без отступов
    std::string pretty_serialized = j.dump(4);  // С отступами

    std::cout << "Serialized JSON: " << serialized << std::endl;
    std::cout << "Pretty JSON: " << pretty_serialized << std::endl;

    return 0;
}
```

### 8. **Обработка ошибок**

Если JSON-строка некорректна или содержимое неверно, библиотека выбросит исключение. Например, при неправильном формате строки в процессе парсинга:

```cpp
try {
    json j = json::parse("Invalid JSON String");
} catch (json::parse_error& e) {
    std::cerr << "Parsing error: " << e.what() << std::endl;
}
```

### 9. **Дополнительные возможности**

- **Проверка типов:** Для безопасной работы с JSON можно использовать методы `is_*`, например `is_string()`, `is_number()`, `is_boolean()` и т.д.
  
- **Проверка наличия ключа:** Метод `contains()` проверяет наличие ключа в JSON-объекте.
  
- **Итерирование по объекту:** Вы можете итерироваться по ключам и значениям JSON-объекта.

#### Пример:

```cpp
for (auto& [key, value] : j.items()) {
    std::cout << key << " : " << value << std::endl;
}
```

#### **5. Заключение**

- `std::optional` полезен, когда вам нужно явно указать, что значение может отсутствовать.
- `std::variant` подходит для случаев, когда одно поле может хранить значения различных типов.
- `std::any` используется в случаях, когда тип данных известен только во время выполнения или когда нужно создать контейнер для данных любого типа.
- использование этих типов данных в реальных ситуациях, например при работе с неопределёнными данными в JSON. 

---

#### **6. Домашнее задание:**

 - Задачи L05-*

